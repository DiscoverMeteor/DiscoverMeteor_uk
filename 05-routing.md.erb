---
title: Маршрутизація
slug: маршрутизація
date: 0005/01/01
number: 5
contents: Навчитесь маршрутизації в Meteor.|Створите сторінки обговорення посту з унікальними URL.|Навчитесь як правильно створювати ссилки на ці сторінки.
paragraphs: 72
---

Тепер ми маємо список постів (які будуть затверджуватись користувачем) і нам потрібна окрема сторінка посту, де наші користувачі зможуть обговорювати кожен пост.

Ми хотіли б, щоб ці сторінки були доступні через *постійну ссилку* -- URL у вигляді `http://myapp.com/posts/xyz` (де `xyz` - це `_id` ідентифікатор) унікальний для кожного посту. 

Це значить, що нам треба деяке *маршрутування* для того, щоб глянути що знаходиться в рядку пошуку браузера і видати відповідний правильний контент.

### Додавання пакету Iron Router

[Iron Router](https://github.com/EventedMind/iron-router) -- це пакет маршрутизації, розробленний спеціально для Meteor додатків. 

Він не тільки допомагає з маршрутизацією (встановленням шляхів), але також він може ставити фільтри (призначаючи деякі дії для цих шляхів) і даже управляти підписками (контроль який шлях має доступ до яких данних). (Занотуйте: Iron Router був розроблений за участі співавтором книги *Discover Meteor* Томом Коулманом.)

По-перше, давайте встановимо пакет з Atmosphere: 

~~~bash
$ meteor add iron:router
~~~
<%= caption "Terminal" %>

Ця команда завантажує і інсталює пакет iron-router в наш додаток, готовий до використання. Зверніть увагу, що інколи вам треба рестартувати ваш Meteor додаток (через `ctrl+c` для вбивства процесу, тоді `meteor` стартує його знову) перед використанням пакету.

Зверніть увагу, що Iron Router це пакет 3-ої сторони, що значить вам треба буде Meteorite для його установки (`meteor add iron-router` не спрацює).

<% note do %>

### Словник маршрутизатора

Ми розглянемо багато різних функцій маршрутизатора в даному розділі. Якщо у вас вже є певний досвід з таким фреймворком як Rails, то ви вже знайомі з більшістю даних концепцій. Але якщо ні, то ось короткий словник для прискорення навчання:

- **Маршрут**: Маршрут -- це базовий будівельний блок маршрутизації. Він є набором інструкцій, який повідомляє додатку куди йти і що робити, коли він отримує URL. 
- **Шляхи**: Шлях -- це URL всередині вашого додатку. Він може бути статичним (`/terms_of_service`) або динамічним (`/posts/xyz`) і навіть включати параметри запиту (`/search?keyword=meteor`).
- **Сегменти**: Різні частини шляху відокремленні косою рискою (`/`).
- **Хуки**: Хуки -- це дії, що вам необхідно виконати до, після або, навіть, під час процесу маршрутизації. Типовим прикладом є перевірка чи користувач має права перед відображенням сторінки.
- **Фільтри**: Фільтри -- це просто хуки, які ви визначаєте глобально для одного чи більше маршрутів.
- **Шаблони маршрутизації**: Кожен маршрут повинен вести до шаблону. Якщо ви не вказали його, то маршрутизатор буде шукати шаблон з таким же іменем за замовчуванням.
- **Макети**: Ви можете думати про макети як про один з тих цифрових фоторамок. Вони містять весь HTML код, що обгортає поточний шаблон і буде залишатися таким же, навіть при зміні шаблону.
- **Контроллери**: Інколи ви будете усвідомлювати, що багато ваших шаблонів використовують однакові параметри. Щоб не дублювати код, ви можете дозволити всім цим маршрутам наслідовати один *контроллер маршруту*, який буде містити всю маршрутну логіку.

Для більшої інформації про Iron Router, перевірте [повну документацію на GitHub](https://github.com/EventedMind/iron-router). 

<% end %>

### Маршрутизація: прив’язка ссилок до шаблонів

Як бачите, ми побудували наш макет використовуючи важкі кодові шаблонні включення (такі як `{{>postsList}}`).  Але хоча контент нашого додатку може змінюватись, базова структура сторінки завжди одна й та ж: шапка зі списком постів знизу.

Iron Router дозволяє нам вирватися з цього болота шляхом взяття на себе того, що рендериться всередині HTML тегу `<body>`. Тому ми не будемо визначати тег контенту, як би ми звичайно робили зі звичайною HTML сторінкою. Замість цього ми направимо маршрутизатор до спеціального макетного шаблону, що містить помічник шаблону `{{> yield}}`. 

Цей `{{> yield}}` помічник визначає спеціальну динамічну зону, яка автоматично відрендерить те, що шаблон визначив до поточного шляху (домовимося, що тепер ми будемо називати цей спеціальний шаблон як “шаблон маршрутизації):

<%= diagram "router-diagram", "Макети і шаблони.", "pull-center" %>

Ми почнемо з створення нашого макету и добавимо помічник `{{> yield}}`. По-перше, ми видалимо наш HTML `<body>` тег з `main.html` і перекинемо його зміст в його власний шаблон `layout.html`.

Таким чином наш зменшенний `main.html` виглядає тепер так:

~~~html
<head>
  <title>Microscope</title>
</head>
~~~
<%= caption "client/main.html" %>

Новостворенний `layout.html` буде містити зовнішній макет додатку:

~~~html
<template name="layout">
  <div class="container">
    <header class="navbar">
      <div class="navbar-inner">
        <a class="brand" href="/">Microscope</a>
      </div>
    </header>
    <div id="main" class="row-fluid">
      {{> yield}}
    </div>
  </div>
</template>
~~~
<%= caption "client/views/application/layout.html" %>

Ви помітите, що ми замінили включення шаблону `postsList` з викликом помічника `yield`. Ви помітите, що після цієї зміни ми нічого не побачимо на екрані. Це тому що ми ще не повідомили маршрутизатор, що нам робити з `/` URL, тому він просто видає пустий шаблон.

Для початку, нам потрібно відтворити стару поведінку прив’язавши кореневий `/` URL до шаблону `postsList`. Ми створимо директорію `/lib` в корні нашого проекту і всередині його створимо `router.js` :

~~~js
Router.configure({
  layoutTemplate: 'layout'
});

Router.map(function() {
  this.route('postsList', {path: '/'});
});
~~~
<%= caption "lib/router.js"%>

Ми зробили дві важливі речі. По-перше, ми наказали маршрутизатору використовувати щойно створенний макет за замовчуванням для всіх маршрутів. По-друге, ми визначили новий маршрут під назвою `postsList` і зв’язали його до шляху `/`. 

<% note do %>

### Каталог `/lib`

Все, що ви кладете всередину теки `/lib` гарантовано завантажиться найпершим перед усім іншим у вашому додатку (можливе виключення - це при використанні смарт-пакетів). Це дуже добре місце для будь-якого коду помічника, до якого потрібен доступ увесь час.

Тому маленьке застереження: зверніть увагу, що так як тека `/lib` не знаходиться в `/client` або `/server`, то це значить її змість буде доступний для обох середовищ.

<% end %>

### Маршрути з іменем

Давайте позбавимось тут деякої неоднозначності. Ми назвали наш маршрут `postsList`, але також ми маємо шаблон *template* з назвою `postsList`. Що це буде?

За замовчуванням, Iron Router буде шукати шаблон з таким же іменем, що і маршрут. Насправді, він навіть буде шукати *path*, базуючись на імені маршрута, що значить, що якщо у нас немає визначенного шляху (який ми зробили через визначення опції `path` в нашому визначенні маршруту), то наш шаблон буде доступний за URL `/postsList` за замовчуванням.

Ви може будете гадати, навіщо нам спочатку давати імена нашим маршрутам. Іменування маршрутів дозволяє нам використовувати декілька функцій Iron Router, що полегшує побудову ссилок всередині нашого додатку. Найбільш корисним є помічник `{{pathFor}}` Spacebars helper,  which returns the URL path component of any route.

We want our main home link to point us back to the posts list, so instead of specifying a static `/` URL, we can also use the Spacebars helper. The end result will be the same, but this gives us more flexibility since the helper will always output the right URL even if we change the route's path in the router. 

~~~html
<header class="navbar">
  <div class="navbar-inner">
    <a class="brand" href="{{pathFor 'postsList'}}">Microscope</a>
  </div>
</header>

//...
~~~
<%= caption "client/views/application/layout.html"%>
<%= highlight "3" %>

<%= commit "5-1", "Дуже базова маршрутизація." %>

### Очікування данних

Якщо ви розміщите поточну версію додатку (або запускати інстанцію використавши ссилку вище), то ви помітите, що список з’являється пустим трошки раніше від появи постів. Це стається тому що спочатку завантажується сторінка і немає постів для відображення поки `posts` підписка не оформиться шляхом отримання данних постів від сервера.

Було б краще для UX спочатку відобразити деяку графічну інформацію про те, що щось відбувається і що користовачу треба трохи зачекати.

На щастя Iron Router дає нам легкий шлях вирішення цього -- `waitOn` підписка:

~~~js
Router.configure({
  layoutTemplate: 'layout',
  loadingTemplate: 'loading',
  waitOn: function() { return Meteor.subscribe('posts'); }
});

Router.map(function() {
  this.route('postsList', {path: '/'});
});

Router.onBeforeAction('loading');
~~~
<%= caption "lib/router.js" %>
<%= highlight "3,4, 11" %>

Давайте докладно розберемося. По-перше, ми змінили блок `Router.configure()` для надання маршрутизатору імені шаблону для завантаження (який ми скоро створимо) для редиректу на час очікування данних.

По-друге, ми також додали функцію `waitOn`, яка повертає нашу підписку `posts`. Нарешті ми зробили доступною побудову в `loading` хуку. Це значить, що маршрутизатор буде перевіряти, що підписка `posts` завантажилась перед відправкою користувача по запитаним маршрутам.

Зверніть увагу, що оскільки мі візначаємо нашу функцію `waitOn` глобально на рівні маршрутизатора, то ця послідовність відбудеться тільки коли користувач вперше звертається до вашого додатку. Після того, дані будуть завантажуватись в пам’ять браузера і маршрутизатору не потрібно буде знову їх чекати.

І так як ми дозволяємо маршрутизатору керувати нашою підпискою, то ви можете безпечно видалити її з `main.js` (який тепер буде пустим). 

Є хорошою практикою чекати на вашу підписку, а не просто заради UX, а також тому, що це значить, що ви можете безпечно вважати, що дані будуть завжди доступними всередині шаблону. Це позбавляє необхідності мати справу з шаблонами, що рендеряться перед доступністю нижчих данних, що часто вимагає усіляких хитромудрих комбінацій. 

Ми також добавили фільтр `onBeforeAction` для запуску Iron Router вбудованого `loading` хуку і впевнилися, що ми показуємо шаблон завантаження поки ми чекаємо.

Фінальним куском пазлу є поточний шаблон завантаження. Ми будемо використовувати `spin` пакет для створення прикольного анімованого спінера завантаження. Добавте його за допомогою `meteor add sachag:spin`, а далі створіть шаблон завантаження як приведено нижче:

~~~html
<template name="loading">
  {{>spinner}}
</template>
~~~
<%= caption "client/views/includes/loading.html" %>

Зверніть увагу, що `{{>spinner}}` - це частинка, що знаходиться в пакеті `spin`. І навіть коли ця частинка знаходиться “поза” нашого додатку, ми можемо включати її так само як і будь-який шаблон. 

<%= commit "5-2", "Зачекайте підписки на пост." %>

<% note do %>

### Перший погляд на реактивність

Реактивність - це базова частина Meteor і хоча ми ще не розповідали про неї, наш шаблон завантаження дає нам перше уявлення цієї концепції.

Редирект до шаблону завантаження, якщо дані ще не завантажились - це добре, але як маршрутизатор знає, коли перенаправляти користувача *назад* до правильної сторінки, коли дані прийдуть?

На разі, давайте скажемо, що це саме тей момент, коли стає в нагоді реактивність і залишимо це як є. Але не хвилюйтесь, ви навчитеся більшого дуже скоро!

<% end %>

### Маршрутизація до певного посту

Тепер, коли ми побачили як направляти до шаблону `postsList`, давайте встановимо шлях для видачі частин окремого посту.

Є одна особливість: ми не можемо поспішати і визначати один маршрут для кожного посту, так як може бути сотні них. Тому нам необхідно встановити єдиний  *динамічний* маршрут і видавати даний маршрут для кожного потрібного посту.

Для початку, створимо новий шаблон, що просто рендерить такий само шаблон, який ми використовували раніше для списку постів.

~~~html
<template name="postPage">
  {{> postItem}}
</template>
~~~
<%= caption "client/views/posts/post_page.html" %>

Добавимо більше елементів до цього шаблону пізніше (таких як коментарі), але на разі будемо видавати все як `{{> postItem}}`. 

Ми збираємося створити ще один маршрут з іменем, прив’язавши наші URL шляхи у формі `/posts/<ID>` до шаблону `postPage`:

~~~js
Router.map(function() {
  this.route('postsList', {path: '/'});
  
  this.route('postPage', {
    path: '/posts/:_id'
  });
});

~~~
<%= caption "lib/router.js" %>
<%= highlight "4~6" %>

Спеціальний синтакс `:_id` повідомляє маршрутизатору дві речі: по-перше, співставити будь-який маршрут у формі `/posts/xyz/`, де “xyz” може бути все що завгодно. По-друге, віддати все, що він знайде в цій “xyz” штуці всередині `_id` параметру в масив роутера `params`. 

Зверніть увагу, що ми тільки використовуємо `_id` для зручності. Рутер не знає чи ви передаєте дійсно існуючий `_id` чи просто якийсь випадковий рядок символів.

Тепер ми проведемо маршрут до правильного шаблону, але у нас ще чогось не вистачає: роутер знає `_id` посту, що нам треба вивести, але шаблон поки що не має ключа. Як ми подолаємо цю розбіжність?

На щастя роутер має розумне встроєне рішення: він дозволяє визначити вам **контекст даних шаблону**. Ви можете думати про контекст даних як заповнення всередині чудового тістечка, зробленного з шаблонів і макетів. Просто визначіть, чим вам треба заповнити ваші шаблони:

<%= diagram "router-diagram-2", "Контекст даних.", "pull-center" %>

У нашому випадку, ми можемо отримати відповідний контекст даних пошукавши наш пост, базуючись на `_id`, який ми отримали з URL: 

~~~js
Router.map(function() {
  this.route('postsList', {path: '/'});
  
  this.route('postPage', {
    path: '/posts/:_id',
    data: function() { return Posts.findOne(this.params._id); }
  });
});

~~~
<%= caption "lib/router.js" %>
<%= highlight "4~7" %>

Кожного разу, коли користувач йде по цьому маршруту, ми знаходимо відповідний пост і передаємо його в шаблон. Пам’ятайте, що метод `findOne` повертає єдиний пост, що відповідає запиту і далі віддає просто `id` як аргумент, що є скороченним записом `{_id: id}`. 

Всередині функції `data` для маршруту, вираз `this` відповідає поточному співставленному маршруту і ми можемо використовувати `this.params` для доступу до іменованих частин маршруту (який ми ідентифікували поставивши префікс `:` перед ними всередині нашого `path`).

<% note do %>

### Більше про контексти даних

Встановивши шаблонний *контекст данних*, ви можете контролювати значення `this` всередині помічників шаблону.

Це звичайно робиться неявно за допомогою `{{#each}}` ітератору, який автоматично встановлює контекст данних для кожної ітерації ітерованого елементу:

~~~html
{{#each widgets}}
  {{> widgetItem}}
{{/each}}
~~~

Ми також можемо це робити неявно, використовуючи `{{#with}}`, який просто каже "візьми цей об’єкт і використай для нього цей шаблон". Наприклад, ми можемо написати:

~~~html
{{#with myWidget}}
  {{> widgetPage}}
{{/with}}
~~~

З’ясовується, що ви можете досягти того самого результату передавши контекст як *аргумент* до виклику шаблону. Тому попередній блок коду можна переписати наступним чином:

~~~js
{{> widgetPage myWidget}}
~~~

<% end %>

### Використання динамічно-іменного помічника маршруту

Нарешті нам необхідно впевнитись, що ми вказуємо на правильне місце, коли ми хочему дати ссилку на окремий пост. Знову, ми можемо зробити щось подібне на `<a href="/posts/{{_id}}">`, але використання помічника маршруту - це набагато надійніше. 

Ми назвали маршрут посту `postPage`, тому ми можемо використовувати помічник `{{pathFor 'postPage'}}`:

~~~html
<template name="postItem">
  <div class="post">
    <div class="post-content">
      <h3><a href="{{url}}">{{title}}</a><span>{{domain}}</span></h3>
    </div>
    <a href="{{pathFor 'postPage'}}" class="discuss btn">Discuss</a>
  </div>
</template>
~~~
<%= caption "client/views/posts/post_item.html"%>
<%= highlight "6" %>
<%= commit "5-3", "Маршрутизація до окремої сторінки посту." %>

Але зачекайте, як же роутер знає, де отримувати `xyz` частину в `/posts/xyz`? Ми ж не передаємо її ніякими `_id`. 

З’ясовується, що цей Iron Router достатньо розумний, щоб з’ясувати це самому. Ми повідомляємо роутеру, що треба використовувати маршрут `postPage` і роутер знає, що цей маршрут вимагає `_id` чи щось типу того (в залежності від того, як ми визначили наш `path`) .

Тому роутер буде шукати цей `_id` в найбільш логічному для цього місці: в контексті даних в `{{pathFor 'postPage'}}` помічнику, іншими словами - `this`. І так сталось, що наш `this` відповідає посту, який (о диво!) володіє параметром `_id`. 

Альтернативно, ви також можете перестрахуватись і повідомити роутер, де б вам хотілося, щоб він шукав `_id` параметр, шляхом надання другого аргументу для помічника (наприклад, `{{pathFor 'postPage' someOtherPost}}`). Практичне використання цього паттерну - це отримання ссилки на попередній і наступний пости у списку. 

Щоб побачити, чи працює воно правильно, перейдіть до списку постів і кляцніть на одну з 'Discuss' ссилок. Ви повинні отриматись щось схоже на:

<%= screenshot "5-2", "Окрема сторінка посту." %>

<% note do %>

### HTML5 pushState

Необхідно зрозуміти одну річ -- зміни цих URL стаються шляхом використання [HTML5 pushState](https://developer.mozilla.org/en-US/docs/Web/Guide/API/DOM/Manipulating_the_browser_history?redirectlocale=en-US&redirectslug=Web%2FGuide%2FDOM%2FManipulating_the_browser_history). 

Рутер бере кляци по ссилкам, що є внутрішніми для сайту і запобігає тому, щоб браузер йшов від додатку, заість цього робить необхідні зміни в стані додатку.

Якщо все правильно робить, то сторінка повинна миттєво змінитися. Фактично, речі інколи змінюються так швидко, що може знадобитись якісь візуальний ефект переходу. Це знаходиться поза межами обговорення данного розділу, але тим не менш є дуже цікавим питанням.

<% end %>