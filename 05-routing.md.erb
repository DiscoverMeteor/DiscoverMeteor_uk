---
title: Маршрутизація
slug: маршрутизація
date: 0005/01/01
number: 5
contents: Навчитесь маршрутизації в Meteor.|Створите сторінки обговорення посту з унікальними URL.|Навчитесь як правильно створювати ссилки на ці сторінки.
paragraphs: 72
---

Тепер ми маємо список постів (які будуть затверджуватись користувачем) і нам потрібна окрема сторінка посту, де наші користувачі зможуть обговорювати кожен пост.

Ми хотіли б, щоб ці сторінки були доступні через *постійну ссилку* -- URL у вигляді `http://myapp.com/posts/xyz` (де `xyz` - це `_id` ідентифікатор) унікальний для кожного посту. 

Це значить, що нам треба деяке *маршрутування* для того, щоб глянути що знаходиться в рядку пошуку браузера і видати відповідний правильний контент.

### Додавання пакету Iron Router

[Iron Router](https://github.com/EventedMind/iron-router) -- це пакет маршрутизації, розробленний спеціально для Meteor додатків. 

Він не тільки допомагає з маршрутизацією (встановленням шляхів), але також він може ставити фільтри (призначаючи деякі дії для цих шляхів) і даже управляти підписками (контроль який шлях має доступ до яких данних). (Занотуйте: Iron Router був розроблений за участі співавтором книги *Discover Meteor* Томом Коулманом.)

По-перше, давайте встановимо пакет з Atmosphere: 

~~~bash
$ meteor add iron:router
~~~
<%= caption "Terminal" %>

Ця команда завантажує і інсталює пакет iron-router в наш додаток, готовий до використання. Зверніть увагу, що інколи вам треба рестартувати ваш Meteor додаток (через `ctrl+c` для вбивства процесу, тоді `meteor` стартує його знову) перед використанням пакету.

Зверніть увагу, що Iron Router це пакет 3-ої сторони, що значить вам треба буде Meteorite для його установки (`meteor add iron-router` не спрацює).

<% note do %>

### Словник маршрутизатора

Ми розглянемо багато різних функцій маршрутизатора в даному розділі. Якщо у вас вже є певний досвід з таким фреймворком як Rails, то ви вже знайомі з більшістю даних концепцій. Але якщо ні, то ось короткий словник для прискорення навчання:

- **Маршрут**: Маршрут -- це базовий будівельний блок маршрутизації. Він є набором інструкцій, який повідомляє додатку куди йти і що робити, коли він отримує URL. 
- **Шляхи**: Шлях -- це URL всередині вашого додатку. Він може бути статичним (`/terms_of_service`) або динамічним (`/posts/xyz`) і навіть включати параметри запиту (`/search?keyword=meteor`).
- **Сегменти**: Різні частини шляху відокремленні косою рискою (`/`).
- **Хуки**: Хуки -- це дії, що вам необхідно виконати до, після або, навіть, під час процесу маршрутизації. Типовим прикладом є перевірка чи користувач має права перед відображенням сторінки.
- **Фільтри**: Фільтри -- це просто хуки, які ви визначаєте глобально для одного чи більше маршрутів.
- **Шаблони маршрутизації**: Кожен маршрут повинен вести до шаблону. Якщо ви не вказали його, то маршрутизатор буде шукати шаблон з таким же іменем за замовчуванням.
- **Макети**: Ви можете думати про макети як про один з тих цифрових фоторамок. Вони містять весь HTML код, що обгортає поточний шаблон і буде залишатися таким же, навіть при зміні шаблону.
- **Контроллери**: Інколи ви будете усвідомлювати, що багато ваших шаблонів використовують однакові параметри. Щоб не дублювати код, ви можете дозволити всім цим маршрутам наслідовати один *контроллер маршруту*, який буде містити всю маршрутну логіку.

Для більшої інформації про Iron Router, перевірте [повну документацію на GitHub](https://github.com/EventedMind/iron-router). 

<% end %>

### Маршрутизація: прив’язка ссилок до шаблонів

Як бачите, ми побудували наш макет використовуючи важкі кодові шаблонні включення (такі як `{{>postsList}}`).  Але хоча контент нашого додатку може змінюватись, базова структура сторінки завжди одна й та ж: шапка зі списком постів знизу.

Iron Router дозволяє нам вирватися з цього болота шляхом взяття на себе того, що рендериться всередині HTML тегу `<body>`. Тому ми не будемо визначати тег контенту, як би ми звичайно робили зі звичайною HTML сторінкою. Замість цього ми направимо маршрутизатор до спеціального макетного шаблону, що містить помічник шаблону `{{> yield}}`. 

Цей `{{> yield}}` помічник визначає спеціальну динамічну зону, яка автоматично відрендерить те, що шаблон визначив до поточного шляху (домовимося, що тепер ми будемо називати цей спеціальний шаблон як “шаблон маршрутизації):

<%= diagram "router-diagram", "Макети і шаблони.", "pull-center" %>

Ми почнемо з створення нашого макету и добавимо помічник `{{> yield}}`. По-перше, ми видалимо наш HTML `<body>` тег з `main.html` і перекинемо його зміст в його власний шаблон `layout.html`.

Таким чином наш зменшенний `main.html` виглядає тепер так:

~~~html
<head>
  <title>Microscope</title>
</head>
~~~
<%= caption "client/main.html" %>

Новостворенний `layout.html` буде містити зовнішній макет додатку:

~~~html
<template name="layout">
  <div class="container">
    <header class="navbar">
      <div class="navbar-inner">
        <a class="brand" href="/">Microscope</a>
      </div>
    </header>
    <div id="main" class="row-fluid">
      {{> yield}}
    </div>
  </div>
</template>
~~~
<%= caption "client/views/application/layout.html" %>

Ви помітите, що ми замінили включення шаблону `postsList` з викликом помічника `yield`. Ви помітите, що після цієї зміни ми нічого не побачимо на екрані. Це тому що ми ще не повідомили маршрутизатор, що нам робити з `/` URL, тому він просто видає пустий шаблон.

Для початку, нам потрібно відтворити стару поведінку прив’язавши кореневий `/` URL до шаблону `postsList`. Ми створимо директорію `/lib` в корні нашого проекту і всередині його створимо `router.js` :

~~~js
Router.configure({
  layoutTemplate: 'layout'
});

Router.map(function() {
  this.route('postsList', {path: '/'});
});
~~~
<%= caption "lib/router.js"%>

Ми зробили дві важливі речі. По-перше, ми наказали маршрутизатору використовувати щойно створенний макет за замовчуванням для всіх маршрутів. По-друге, ми визначили новий маршрут під назвою `postsList` і зв’язали його до шляху `/`. 

<% note do %>

### Каталог `/lib`

Все, що ви кладете всередину теки `/lib` гарантовано завантажиться найпершим перед усім іншим у вашому додатку (можливе виключення - це при використанні смарт-пакетів). Це дуже добре місце для будь-якого коду помічника, до якого потрібен доступ увесь час.

Тому маленьке застереження: зверніть увагу, що так як тека `/lib` не знаходиться в `/client` або `/server`, то це значить її змість буде доступний для обох середовищ.

<% end %>

### Маршрути з іменем

Давайте позбавимось тут деякої неоднозначності. Ми назвали наш маршрут `postsList`, але також ми маємо шаблон *template* з назвою `postsList`. Що це буде?

За замовчуванням, Iron Router буде шукати шаблон з таким же іменем, що і маршрут. Насправді, він навіть буде шукати *path*, базуючись на імені маршрута, що значить, що якщо у нас немає визначенного шляху (який ми зробили через визначення опції `path` в нашому визначенні маршруту), то наш шаблон буде доступний за URL `/postsList` за замовчуванням.

Ви може будете гадати, навіщо нам спочатку давати імена нашим маршрутам. Іменування маршрутів дозволяє нам використовувати декілька функцій Iron Router, що полегшує побудову ссилок всередині нашого додатку. Найбільш корисним є помічник `{{pathFor}}` Spacebars helper,  which returns the URL path component of any route.

We want our main home link to point us back to the posts list, so instead of specifying a static `/` URL, we can also use the Spacebars helper. The end result will be the same, but this gives us more flexibility since the helper will always output the right URL even if we change the route's path in the router. 

~~~html
<header class="navbar">
  <div class="navbar-inner">
    <a class="brand" href="{{pathFor 'postsList'}}">Microscope</a>
  </div>
</header>

//...
~~~
<%= caption "client/views/application/layout.html"%>
<%= highlight "3" %>

<%= commit "5-1", "Very basic routing." %>

### Waiting on Data

Якщо ви розміщите поточну версію додатку (або запускати інстанцію використавши ссилку вище), то ви помітите, що список з’являється пустим трошки раніше від появи постів. Це стається тому що спочатку завантажується сторінка і немає постів для відображення поки `posts` підписка не оформиться шляхом отримання данних постів від сервера.

Було б краще для UX спочатку відобразити деяку графічну інформацію про те, що щось відбувається і що користовачу треба трохи зачекати.

На щастя Iron Router дає нам легкий шлях вирішення цього -- `waitOn` підписка:

~~~js
Router.configure({
  layoutTemplate: 'layout',
  loadingTemplate: 'loading',
  waitOn: function() { return Meteor.subscribe('posts'); }
});

Router.map(function() {
  this.route('postsList', {path: '/'});
});
~~~
<%= caption "lib/router.js" %>
<%= highlight "3,4" %>

////

////

////

////

////

////

~~~html
<template name="loading">
  {{>spinner}}
</template>
~~~
<%= caption "client/views/includes/loading.html" %>

////

<%= commit "5-2", "Зачекайте підписки на пост." %>

<% note do %>

### Перший погляд на реактивність

////

////

////

<% end %>

### Маршрутизація до певного посту

////

////

////

~~~html
<template name="postPage">
  {{> postItem}}
</template>
~~~
<%= caption "client/views/posts/post_page.html" %>

////

////

~~~js
Router.map(function() {
  this.route('postsList', {path: '/'});
  
  this.route('postPage', {
    path: '/posts/:_id'
  });
});

~~~
<%= caption "lib/router.js" %>
<%= highlight "4~6" %>

////

////

////

////

<%= diagram "router-diagram-2", "The data context.", "pull-center" %>

////

~~~js
Router.map(function() {
  this.route('postsList', {path: '/'});
  
  this.route('postPage', {
    path: '/posts/:_id',
    data: function() { return Posts.findOne(this.params._id); }
  });
});

~~~
<%= caption "lib/router.js" %>
<%= highlight "4~7" %>

////

////

<% note do %>

### Більше про контексти даних

////

////

~~~html
{{#each widgets}}
  {{> widgetItem}}
{{/each}}
~~~

////

~~~html
{{#with myWidget}}
  {{> widgetPage}}
{{/with}}
~~~

////

~~~js
{{> widgetPage myWidget}}
~~~

<% end %>

### Використання динамічно-іменного помічника маршруту

////

////

~~~html
<template name="postItem">
  <div class="post">
    <div class="post-content">
      <h3><a href="{{url}}">{{title}}</a><span>{{domain}}</span></h3>
    </div>
    <a href="{{pathFor 'postPage'}}" class="discuss btn">Discuss</a>
  </div>
</template>
~~~
<%= caption "client/views/posts/post_item.html"%>
<%= highlight "6" %>
<%= commit "5-3", "Routing to a single post page." %>

////

////

////

////

////

<%= screenshot "5-2", "A single post page." %>

<% note do %>

### HTML5 pushState

////

////

////

<% end %>